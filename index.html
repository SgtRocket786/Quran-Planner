<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quran Memorization Planner</title>

<style>
:root {
  --brand:#2c3e50; --bg:#f5f5f5; --ok:#d4edda; --ok-text:#155724;
  --border:#ccc; --white:#fff; --gold:#fff8dc;
}
body {
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  background:var(--bg);
  padding:20px;
}
h1 { text-align:center; color:var(--brand); margin-bottom:16px; }

.controls {
  max-width:960px;
  margin:0 auto 14px;
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:center;
  color:#333;
}
.controls label { font-size:14px; }
.controls input, .controls select {
  padding:6px 8px;
  border:1px solid var(--border);
  border-radius:8px;
  background:var(--white);
}
button {
  background:var(--brand);
  color:white;
  border:none;
  border-radius:8px;
  padding:7px 14px;
  cursor:pointer;
}
button:hover { opacity:.85; }

table {
  width:100%;
  border-collapse:collapse;
  background:var(--white);
  box-shadow:0 0 10px rgba(0,0,0,0.08);
}
th,td {
  border:1px solid var(--border);
  padding:10px;
  text-align:center;
}
th {
  background:var(--brand);
  color:var(--white);
}

tbody tr.completed {
  background-color:var(--ok);
  color:var(--ok-text);
}
tbody tr.recite {
  background:var(--gold);
  font-weight:bold;
}

input[type="checkbox"] { transform:scale(1.2); }

tfoot td {
  font-weight:bold;
  background:#eef;
  color:#000;
  text-align:center;
}

.hidden { display:none; }

@media(max-width:768px){
  table,th,td { font-size:12px; }
}
</style>
</head>

<body>

<h1>Quran Memorization Planner</h1>

<div class="controls">
  <label>Start Page (odd):
    <input id="startPageInput" type="number" min="1" max="604" value="105">
  </label>

  <label>End Page:
    <input id="endPageInput" type="number" min="1" max="604" value="604">
  </label>

  <label>Pages/Day:
    <input id="ppdInput" type="number" min="1" max="10" value="2">
  </label>

  <label>Start Date:
    <input id="startDateInput" type="date">
  </label>

  <label>Date Format:
    <select id="dateFormatSelect">
      <option value="gregorian">Gregorian</option>
      <option value="hijri">Hijri</option>
    </select>
  </label>

  <label>Start Revise From Juz:
    <input id="reviseStartInput" type="number" min="1" max="30" value="1">
  </label>

  <button id="generateBtn">Generate</button>
  <button id="scrollToEndBtn">Jump to Khatm Date â†“</button>
</div>

<table id="planner-table">
<thead>
<tr>
  <th>âœ…</th>
  <th>Day #</th>
  <th class="date-col">Date</th>
  <th>Revise</th>
  <th>Connect</th>
  <th>Memorize</th>
  <th>Read</th>
</tr>
</thead>

<tbody></tbody>

<tfoot>
<tr>
  <td colspan="7" id="summary">
    ðŸ“… Select a Start Date to see expected Khatm date below.
  </td>
</tr>
</tfoot>
</table>

<script>
// ===== Scroll Button =====
document.getElementById("scrollToEndBtn").onclick = () => {
  document.getElementById("summary")
    .scrollIntoView({ behavior:"smooth", block:"center" });
};

// ===== Juz Data =====
const juzStartPages=[1,22,42,62,82,102,121,141,162,182,202,222,242,262,282,302,322,342,362,382,402,422,442,462,482,502,522,542,562,582];
function getJuzForPage(p){
  for(let i=juzStartPages.length-1;i>=0;i--)
    if(p>=juzStartPages[i]) return i+1;
  return 1;
}

// ===== Hijri Utils =====
const hijriMonths=["Ù…Ø­Ø±Ù…","ØµÙØ±","Ø±Ø¨ÙŠØ¹ Ø§Ù„Ø£ÙˆÙ„","Ø±Ø¨ÙŠØ¹ Ø§Ù„Ø¢Ø®Ø±","Ø¬Ù…Ø§Ø¯Ù‰ Ø§Ù„Ø£ÙˆÙ„Ù‰","Ø¬Ù…Ø§Ø¯Ù‰ Ø§Ù„Ø¢Ø®Ø±Ø©","Ø±Ø¬Ø¨","Ø´Ø¹Ø¨Ø§Ù†","Ø±Ù…Ø¶Ø§Ù†","Ø´ÙˆØ§Ù„","Ø°Ùˆ Ø§Ù„Ù‚Ø¹Ø¯Ø©","Ø°Ùˆ Ø§Ù„Ø­Ø¬Ø©"];
function gregorianToHijri(d){
  const jd=Math.floor(d.getTime()/86400000+2440587.5);
  const l=jd-1948440+10632,n=Math.floor((l-1)/10631);
  const l2=l-10631*n+354;
  const j=Math.floor((10985-l2)/5316)*Math.floor(50*l2/17719)
        +Math.floor(l2/5670)*Math.floor(43*l2/15238);
  const l3=l2-Math.floor((30-j)/15)*Math.floor(17719*j/50)
        -Math.floor(j/16)*Math.floor(15238*j/43)+29;
  const m=Math.floor(24*l3/709);
  return { day:l3-Math.floor(709*m/24), month:m, year:30*n+j-30 };
}
const toArabic=n=>n.toString().replace(/\d/g,d=>"Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©"[d]);
const hijriStr=h=>`${toArabic(h.day)} ${hijriMonths[h.month-1]} ${toArabic(h.year)}`;
const weekday=d=>d.toLocaleDateString("en-US",{weekday:"long"});
function engDate(d){
  const x=d.getDate();
  const s=(x%10==1&&x!=11)?"st":(x%10==2&&x!=12)?"nd":(x%10==3&&x!=13)?"rd":"th";
  return `${x}${s} ${d.toLocaleString("en-US",{month:"long"})} ${d.getFullYear()}`;
}

// ===== Build Table =====
function buildTable(){
  const startP=+startPageInput.value,endP=+endPageInput.value,ppd=+ppdInput.value;
  const sDateVal=startDateInput.value;
  const dateMode=dateFormatSelect.value;
  const startReviseRaw=Math.max(1,Math.min(30,+reviseStartInput.value||1));

  const tbody=document.querySelector("tbody");
  const summary=document.getElementById("summary");
  const dateHeader=document.querySelector(".date-col");
  tbody.innerHTML="";

  if(!sDateVal) dateHeader.classList.add("hidden");
  else dateHeader.classList.remove("hidden");

  let p=startP,day=1;

  // Memorization juz tracking
  let curJuz=getJuzForPage(startP);
  let curJuzStart=juzStartPages[curJuz-1];
  let curJuzEnd=(juzStartPages[curJuz]||605)-1;

  // âœ… NEW RULE:
  // Revise cycle should NOT include the Juz currently being memorized.
  // So reviseMax = (completed juz count) = curJuz - 1 (until you finish it).
  let completedJuz = Math.max(0, curJuz - 1);
  let reviseMax = completedJuz; // 0 means no revise yet (you're in Juz 1)

  // Revise pointer: 1..reviseMax (or 0 if none)
  let revisePtr = (reviseMax >= 1) ? (((startReviseRaw - 1) % reviseMax) + 1) : 0;

  const startDate=sDateVal?new Date(sDateVal):null;

  // Recite-just-finished-juz on NEXT day
  let pendingRecite = null;

  // Post-memorization tail (keep Revise/Listen/Day/Date until revise cycle completes)
  let memFinished = false;
  let memFinishedAtRevisePtr = null;
  let memFinishedAtReviseMax = null;

  while(true){
    const memActive = !memFinished && (p <= endP);

    const memStart = memActive ? p : null;
    const memEnd = memActive ? Math.min(endP, p + ppd - 1) : null;

    // Snapshot for this row
    const reviseTodayMax = reviseMax;
    const reviseTodayPtr = revisePtr;

    // Will you finish the current memorization Juz TODAY?
    const finishesMemJuzToday = memActive && (memEnd >= curJuzEnd);

    // Compute next day's reviseMax (because finishing a juz increases completed)
    let completedNext = completedJuz + (finishesMemJuzToday ? 1 : 0);
    if(memActive && (p + ppd > endP)) completedNext = 30; // finishing Qur'an sets completed to 30
    const reviseNextMax = Math.max(0, completedNext);

    // Compute next day's revise pointer (for Listen + state update)
    let reviseNextPtr = 0;
    if(reviseNextMax >= 1){
      if(reviseTodayMax === 0){
        // first time revise becomes available: start at user-chosen start
        reviseNextPtr = (((startReviseRaw - 1) % reviseNextMax) + 1);
      } else {
        const candidate = (reviseTodayPtr < reviseTodayMax) ? (reviseTodayPtr + 1) : 1;
        reviseNextPtr = candidate; // candidate is always within 1..reviseTodayMax âŠ† 1..reviseNextMax
      }
    }

    const tr=document.createElement("tr");

    // Checkbox
    const tdCheck=document.createElement("td");
    const cb=document.createElement("input");
    cb.type="checkbox";
    cb.onchange=()=>tr.classList.toggle("completed",cb.checked);
    tdCheck.appendChild(cb);
    tr.appendChild(tdCheck);

    tr.insertCell().textContent=`Day ${day}`;

    // Date (kept EXACTLY per your current code convention)
    if(startDate){
      const d=new Date(startDate);
      d.setDate(startDate.getDate()+day);
      tr.insertCell().textContent =
        dateMode==="hijri" ? hijriStr(gregorianToHijri(d))
                           : d.toLocaleDateString("en-US",{month:"short",day:"numeric",year:"numeric"});
    }

    // Revise display (exclude current memorization juz)
    tr.insertCell().textContent = (reviseTodayMax >= 1) ? `Juz ${reviseTodayPtr}` : "-";

    // Connect / Memorize
    const conn=tr.insertCell();
    const memCell=tr.insertCell();

    if(!memActive){
      conn.textContent = "-";
      memCell.textContent = "-";
    } else {
      // Connect
      if(pendingRecite){
        conn.textContent=`Recite entire Juz ${pendingRecite.juz} (Pg ${pendingRecite.start}â€“${pendingRecite.end})`;
        tr.classList.add("recite");
        pendingRecite=null;
      } else {
        const end=memStart-1;
        if(end > curJuzStart) conn.textContent = `Pg ${curJuzStart}â€“${end}`;
        else conn.textContent = `Pg ${curJuzStart}`;
      }

      // Memorize
      memCell.textContent = (ppd===1) ? `Pg ${memStart}` : `Pg ${memStart}â€“${memEnd}`;
    }

    // Listen = NEXT day's revise (based on reviseNextMax/Ptr)
    tr.insertCell().textContent = (reviseNextMax >= 1) ? `Juz ${reviseNextPtr}` : "-";

    tbody.appendChild(tr);

    // ---- advance day ----
    day++;

    // ---- memorization advance ----
    if(memActive){
      p += ppd;

      // If finished current memorization juz today, schedule recitation for tomorrow
      if(finishesMemJuzToday){
        pendingRecite = { juz: curJuz, start: curJuzStart, end: curJuzEnd };

        // Move to next memorization juz
        curJuz++;
        curJuzStart = juzStartPages[curJuz-1] || 605;
        curJuzEnd = (juzStartPages[curJuz] || 605) - 1;
      }

      // Update completed/revise ceiling AFTER processing end-of-day effects
      completedJuz = completedNext;
      reviseMax = Math.max(0, completedJuz);

      // If we finished Qur'an, stop showing connect/memorize on extra rows
      if(p > endP){
        memFinished = true;
        memFinishedAtRevisePtr = reviseTodayPtr;   // revise shown on LAST memorization row
        memFinishedAtReviseMax = reviseTodayMax;   // reviseMax on LAST memorization row (likely 29 if in Juz 30, etc.)
        pendingRecite = null;
      }
    } else {
      // Post-memorization: reviseMax stays 30 (already true)
      reviseMax = Math.max(0, completedJuz);
    }

    // ---- revise pointer becomes next day's value (computed above) ----
    revisePtr = reviseNextPtr;

    // ---- stop condition ----
    if(memFinished){
      // Once memorization is finished, keep adding rows until the revise cycle completes:
      // i.e. render a row where Revise is the LAST juz in the cycle (reviseMax).
      // If reviseMax is 0 (rare), stop immediately.
      if(reviseMax === 0) break;

      // If the last memorization row already displayed the last juz in the cycle, stop.
      if(memFinishedAtReviseMax === reviseMax && memFinishedAtRevisePtr === reviseMax) break;

      // Otherwise stop after we *render* a row with Revise == reviseMax.
      // We can check the row we just rendered: its reviseTodayPtr / reviseTodayMax.
      if(reviseTodayMax === reviseMax && reviseTodayPtr === reviseMax) break;
    }
  }

  // Summary (end date based on total rows generated)
  if(startDate){
    const totalRows = day - 1;
    const end=new Date(startDate);
    end.setDate(startDate.getDate() + totalRows);
    const h=gregorianToHijri(end);
    summary.innerHTML=`ðŸ“– <strong>Expected Khatm Date:</strong><br>
      ${weekday(end)}, ${engDate(end)}<br>
      ${hijriStr(h)}<br><br>Ø¥Ù† Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡`;
  } else {
    summary.textContent = "ðŸ“… Select a Start Date to see expected Khatm date below.";
  }
}

generateBtn.onclick=buildTable;
dateFormatSelect.onchange=buildTable;
</script>

</body>
</html>